---
phase: 01-rust-node-core-upgrade
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - node-core/Cargo.toml
  - node-core/crates/p2p/Cargo.toml
  - node-core/crates/p2p/src/cert.rs
  - node-core/crates/p2p/src/config.rs
  - node-core/crates/p2p/src/lib.rs
autonomous: true

must_haves:
  truths:
    - "WebRTC dependencies compile without version conflicts"
    - "Certificate can be generated and persisted to disk"
    - "Certificate can be loaded from existing PEM file"
    - "Config struct accepts WebRTC-related fields"
  artifacts:
    - path: "node-core/crates/p2p/src/cert.rs"
      provides: "CertificateManager for WebRTC certificate persistence"
      exports: ["CertificateManager", "CertError"]
      min_lines: 80
    - path: "node-core/crates/p2p/src/config.rs"
      provides: "Extended P2pConfig with WebRTC fields"
      contains: "enable_webrtc"
  key_links:
    - from: "node-core/crates/p2p/Cargo.toml"
      to: "libp2p-webrtc"
      via: "dependency declaration"
      pattern: 'libp2p-webrtc.*features.*tokio.*pem'
    - from: "node-core/crates/p2p/src/lib.rs"
      to: "node-core/crates/p2p/src/cert.rs"
      via: "module export"
      pattern: "pub mod cert"
---

<objective>
Add libp2p-webrtc dependencies and create certificate persistence module for WebRTC transport support.

Purpose: WebRTC transport requires a stable certificate (certhash) that browsers use to verify connections. Without certificate persistence, the certhash changes on every restart, breaking browser connectivity.

Output: Compilable codebase with WebRTC dependencies, CertificateManager module, and extended P2pConfig.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-rust-node-core-upgrade/01-RESEARCH.md

# Source files to modify
@node-core/Cargo.toml
@node-core/crates/p2p/Cargo.toml
@node-core/crates/p2p/src/config.rs
@node-core/crates/p2p/src/identity.rs
@node-core/crates/p2p/src/lib.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add libp2p-webrtc dependency and verify compilation</name>
  <files>
    node-core/Cargo.toml
    node-core/crates/p2p/Cargo.toml
  </files>
  <action>
Add libp2p-webrtc to workspace and p2p crate dependencies.

1. In `node-core/Cargo.toml`, add to [workspace.dependencies]:
```toml
libp2p-webrtc = { version = "0.9.0-alpha.2", features = ["tokio", "pem"] }
```

2. In `node-core/crates/p2p/Cargo.toml`, add to [dependencies]:
```toml
libp2p-webrtc = { workspace = true }
```

3. Also add rand to p2p Cargo.toml if not already present (required for Certificate::generate):
```toml
rand = "0.8"
```
Note: rand 0.8 is already in the crate per Cargo.toml line 46.

4. Run `cargo check -p nsn-p2p` to verify the dependency compiles without version conflicts.

CRITICAL: If version conflicts occur with libp2p 0.53 internal crates, this is a blocking issue. The research noted this as MEDIUM risk due to alpha crate status. If conflicts occur, try:
- Check if libp2p-webrtc 0.8.x exists and is compatible
- Check libp2p-webrtc main branch for unreleased fixes
  </action>
  <verify>
`cargo check -p nsn-p2p` completes without errors. Look for clean compilation output.
  </verify>
  <done>
nsn-p2p crate compiles with libp2p-webrtc dependency. No version conflict errors.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create certificate persistence module</name>
  <files>
    node-core/crates/p2p/src/cert.rs
    node-core/crates/p2p/src/lib.rs
  </files>
  <action>
Create `node-core/crates/p2p/src/cert.rs` with CertificateManager following the pattern from identity.rs.

```rust
//! WebRTC certificate management
//!
//! Provides certificate generation, persistence, and loading for WebRTC transport.
//! Certificates must persist across restarts to maintain stable certhash in multiaddrs.

use libp2p_webrtc::tokio::Certificate;
use std::fs;
use std::path::{Path, PathBuf};
use thiserror::Error;
use tracing::{info, warn};

#[derive(Debug, Error)]
pub enum CertError {
    #[error("IO error: {0}")]
    Io(#[from] std::io::Error),

    #[error("Certificate generation failed: {0}")]
    Generation(String),

    #[error("Certificate parse error: {0}")]
    Parse(String),
}

/// Manages WebRTC certificate persistence
///
/// WebRTC transport requires a certificate for DTLS encryption. The certificate
/// fingerprint (certhash) is included in the multiaddr and must remain stable
/// across restarts for browsers to connect.
pub struct CertificateManager {
    cert_path: PathBuf,
}

impl CertificateManager {
    /// Create a new certificate manager
    ///
    /// # Arguments
    /// * `data_dir` - Directory where certificate will be stored
    pub fn new(data_dir: &Path) -> Self {
        Self {
            cert_path: data_dir.join("webrtc_cert.pem"),
        }
    }

    /// Load existing certificate or generate a new one
    ///
    /// If a certificate exists at the configured path, it is loaded.
    /// Otherwise, a new certificate is generated and saved.
    ///
    /// # Returns
    /// The WebRTC certificate
    pub fn load_or_generate(&self) -> Result<Certificate, CertError> {
        if self.cert_path.exists() {
            info!("Loading WebRTC certificate from {:?}", self.cert_path);
            self.load()
        } else {
            info!("Generating new WebRTC certificate at {:?}", self.cert_path);
            self.generate_and_save()
        }
    }

    /// Load certificate from disk
    fn load(&self) -> Result<Certificate, CertError> {
        let pem = fs::read_to_string(&self.cert_path)?;
        Certificate::from_pem(&pem).map_err(|e| CertError::Parse(format!("{:?}", e)))
    }

    /// Generate a new certificate and save to disk
    fn generate_and_save(&self) -> Result<Certificate, CertError> {
        let cert = Certificate::generate(&mut rand::thread_rng())
            .map_err(|e| CertError::Generation(format!("{:?}", e)))?;

        let pem = cert.serialize_pem();

        // Ensure parent directory exists
        if let Some(parent) = self.cert_path.parent() {
            fs::create_dir_all(parent)?;
        }

        fs::write(&self.cert_path, &pem)?;

        // Set restrictive permissions (Unix only)
        #[cfg(unix)]
        {
            use std::os::unix::fs::PermissionsExt;
            let mut perms = fs::metadata(&self.cert_path)?.permissions();
            perms.set_mode(0o600); // Only owner can read/write
            fs::set_permissions(&self.cert_path, perms)?;
        }

        Ok(cert)
    }

    /// Get the path where the certificate is stored
    pub fn cert_path(&self) -> &Path {
        &self.cert_path
    }

    /// Check if a certificate already exists
    pub fn exists(&self) -> bool {
        self.cert_path.exists()
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use tempfile::TempDir;

    #[test]
    fn test_generate_and_load_certificate() {
        let temp_dir = TempDir::new().expect("Failed to create temp dir");
        let manager = CertificateManager::new(temp_dir.path());

        // First call should generate
        let cert1 = manager.load_or_generate().expect("Failed to generate cert");
        assert!(manager.exists(), "Certificate file should exist");

        // Second call should load existing
        let cert2 = manager.load_or_generate().expect("Failed to load cert");

        // Fingerprints should match (same certificate)
        assert_eq!(
            cert1.fingerprint(),
            cert2.fingerprint(),
            "Loaded certificate should have same fingerprint"
        );
    }

    #[test]
    fn test_certificate_persistence_across_instances() {
        let temp_dir = TempDir::new().expect("Failed to create temp dir");

        // First manager generates
        let manager1 = CertificateManager::new(temp_dir.path());
        let cert1 = manager1.load_or_generate().expect("Failed to generate");
        let fingerprint1 = cert1.fingerprint();

        // Second manager loads same certificate
        let manager2 = CertificateManager::new(temp_dir.path());
        let cert2 = manager2.load_or_generate().expect("Failed to load");
        let fingerprint2 = cert2.fingerprint();

        assert_eq!(
            fingerprint1, fingerprint2,
            "Certificate fingerprint should persist across manager instances"
        );
    }

    #[test]
    fn test_load_nonexistent_generates_new() {
        let temp_dir = TempDir::new().expect("Failed to create temp dir");
        let manager = CertificateManager::new(temp_dir.path());

        assert!(!manager.exists(), "No certificate should exist initially");

        let cert = manager.load_or_generate().expect("Should generate new cert");
        assert!(manager.exists(), "Certificate should exist after generation");

        // Certificate should be valid (has fingerprint)
        let fingerprint = cert.fingerprint();
        assert!(!fingerprint.to_string().is_empty());
    }

    #[cfg(unix)]
    #[test]
    fn test_certificate_file_permissions() {
        use std::os::unix::fs::PermissionsExt;

        let temp_dir = TempDir::new().expect("Failed to create temp dir");
        let manager = CertificateManager::new(temp_dir.path());

        manager.load_or_generate().expect("Failed to generate");

        let metadata = fs::metadata(manager.cert_path()).expect("Failed to get metadata");
        let mode = metadata.permissions().mode();

        assert_eq!(
            mode & 0o777,
            0o600,
            "Certificate file should have restrictive permissions (0o600)"
        );
    }

    #[test]
    fn test_cert_error_display() {
        let err = CertError::Generation("test error".to_string());
        assert!(err.to_string().contains("Certificate generation failed"));

        let err = CertError::Parse("parse error".to_string());
        assert!(err.to_string().contains("Certificate parse error"));
    }
}
```

Then update `node-core/crates/p2p/src/lib.rs` to export the new module:
- Add `pub mod cert;` near the other module declarations
- Add `pub use cert::{CertError, CertificateManager};` to the public re-exports
  </action>
  <verify>
`cargo test -p nsn-p2p cert::` runs all certificate tests and they pass.
  </verify>
  <done>
CertificateManager module exists with load_or_generate(), all tests pass, module exported from lib.rs.
  </done>
</task>

<task type="auto">
  <name>Task 3: Extend P2pConfig with WebRTC fields</name>
  <files>
    node-core/crates/p2p/src/config.rs
  </files>
  <action>
Extend P2pConfig struct to include WebRTC configuration fields.

Add the following fields to the P2pConfig struct in `node-core/crates/p2p/src/config.rs`:

```rust
/// Enable WebRTC transport for browser connections
#[serde(default)]
pub enable_webrtc: bool,

/// UDP port for WebRTC connections (default: 9003)
#[serde(default = "default_webrtc_port")]
pub webrtc_port: u16,

/// Path to data directory for certificate persistence
/// If None, uses system temp directory (not recommended for production)
pub data_dir: Option<PathBuf>,

/// External address to advertise (for NAT/Docker environments)
/// Format: Multiaddr string, e.g., "/ip4/1.2.3.4/udp/9003/webrtc-direct"
pub external_address: Option<String>,
```

Add the default function:
```rust
fn default_webrtc_port() -> u16 {
    9003
}
```

Update the Default impl:
```rust
enable_webrtc: false,
webrtc_port: 9003,
data_dir: None,
external_address: None,
```

Update the test_config_defaults test to verify the new fields.

Add a new test for WebRTC config serialization:
```rust
#[test]
fn test_webrtc_config_fields() {
    let config = P2pConfig {
        enable_webrtc: true,
        webrtc_port: 9003,
        data_dir: Some(PathBuf::from("/var/lib/nsn")),
        external_address: Some("/ip4/1.2.3.4/udp/9003/webrtc-direct".to_string()),
        ..Default::default()
    };

    let json = serde_json::to_string(&config).expect("Failed to serialize");
    let deserialized: P2pConfig = serde_json::from_str(&json).expect("Failed to deserialize");

    assert!(deserialized.enable_webrtc);
    assert_eq!(deserialized.webrtc_port, 9003);
    assert_eq!(deserialized.data_dir, Some(PathBuf::from("/var/lib/nsn")));
    assert!(deserialized.external_address.is_some());
}
```
  </action>
  <verify>
`cargo test -p nsn-p2p config::` runs config tests including new WebRTC field tests.
  </verify>
  <done>
P2pConfig includes enable_webrtc, webrtc_port, data_dir, external_address fields with proper defaults and serialization.
  </done>
</task>

</tasks>

<verification>
Run the following to verify all plan objectives are met:

```bash
# 1. Verify dependencies compile
cargo check -p nsn-p2p

# 2. Run all p2p crate tests
cargo test -p nsn-p2p

# 3. Verify cert module is exported
grep -n "pub mod cert" node-core/crates/p2p/src/lib.rs
grep -n "CertificateManager" node-core/crates/p2p/src/lib.rs

# 4. Verify config has WebRTC fields
grep -n "enable_webrtc" node-core/crates/p2p/src/config.rs
grep -n "webrtc_port" node-core/crates/p2p/src/config.rs
```
</verification>

<success_criteria>
1. `cargo check -p nsn-p2p` succeeds with no errors
2. `cargo test -p nsn-p2p` passes all tests including new cert:: and config:: tests
3. CertificateManager can generate, save, and load certificates (verified by tests)
4. P2pConfig includes enable_webrtc, webrtc_port, data_dir, external_address fields
5. All new code follows existing crate patterns (error handling, logging, tests)
</success_criteria>

<output>
After completion, create `.planning/phases/01-rust-node-core-upgrade/01-01-SUMMARY.md`
</output>
