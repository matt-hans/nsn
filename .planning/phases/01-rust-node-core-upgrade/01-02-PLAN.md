---
phase: 01-rust-node-core-upgrade
plan: 02
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - node-core/crates/p2p/src/service.rs
  - node-core/bin/nsn-node/src/main.rs
autonomous: true

must_haves:
  truths:
    - "Node can listen on WebRTC transport alongside TCP/QUIC"
    - "WebRTC multiaddr includes certhash component"
    - "CLI accepts --p2p-enable-webrtc, --p2p-webrtc-port, --p2p-external-address, --data-dir flags"
    - "External address is advertised when configured"
    - "WebRTC connection events are logged at INFO level"
  artifacts:
    - path: "node-core/crates/p2p/src/service.rs"
      provides: "P2pService with WebRTC transport support"
      contains: "webrtc_transport"
    - path: "node-core/bin/nsn-node/src/main.rs"
      provides: "CLI flags for WebRTC configuration"
      contains: "p2p_enable_webrtc"
  key_links:
    - from: "node-core/crates/p2p/src/service.rs"
      to: "CertificateManager"
      via: "certificate loading"
      pattern: "cert.*load_or_generate"
    - from: "node-core/bin/nsn-node/src/main.rs"
      to: "P2pConfig"
      via: "config construction"
      pattern: "enable_webrtc.*=.*cli"
---

<objective>
Integrate WebRTC transport into P2pService and add CLI configuration flags for WebRTC support.

Purpose: Enables Director and Validator nodes to accept incoming WebRTC connections from browsers. The node will listen on both TCP/QUIC (for mesh peers) and WebRTC (for browsers) simultaneously.

Output: NSN nodes can be started with `--p2p-enable-webrtc` and browsers can connect via WebRTC-direct.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-rust-node-core-upgrade/01-RESEARCH.md
@.planning/phases/01-rust-node-core-upgrade/01-01-SUMMARY.md

# Source files to modify
@node-core/crates/p2p/src/service.rs
@node-core/crates/p2p/src/config.rs
@node-core/bin/nsn-node/src/main.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add WebRTC transport to P2pService swarm</name>
  <files>
    node-core/crates/p2p/src/service.rs
  </files>
  <action>
Modify P2pService::new() to conditionally add WebRTC transport when enabled.

1. Add imports at the top of service.rs:
```rust
use super::cert::CertificateManager;
use libp2p::core::muxing::StreamMuxerBox;
use libp2p_webrtc as webrtc;
```

2. After the keypair loading section (around line 225), add certificate loading when WebRTC is enabled:
```rust
// Load or generate WebRTC certificate if enabled
let webrtc_cert = if config.enable_webrtc {
    let data_dir = config.data_dir.clone().unwrap_or_else(|| {
        std::env::temp_dir().join("nsn-p2p")
    });
    let cert_manager = CertificateManager::new(&data_dir);
    Some(cert_manager.load_or_generate()
        .map_err(|e| ServiceError::Transport(format!("WebRTC certificate error: {}", e)))?)
} else {
    None
};
```

3. Modify the SwarmBuilder chain (around lines 330-342) to conditionally add WebRTC transport:

Replace the current swarm building code with:
```rust
// Build swarm with TCP and QUIC transports
// TCP transport is needed for compatibility with chain-advertised WebSocket addresses
let swarm_builder = SwarmBuilder::with_existing_identity(keypair.clone())
    .with_tokio()
    .with_tcp(
        libp2p::tcp::Config::default(),
        libp2p::noise::Config::new,
        libp2p::yamux::Config::default,
    )
    .map_err(|e| ServiceError::Swarm(format!("TCP transport error: {}", e)))?
    .with_quic();

// Conditionally add WebRTC transport
let mut swarm = if let Some(cert) = webrtc_cert {
    info!("Enabling WebRTC transport with certificate fingerprint: {}", cert.fingerprint());
    swarm_builder
        .with_other_transport(|id_keys| {
            Ok(webrtc::tokio::Transport::new(
                id_keys.clone(),
                cert.clone(),
            )
            .map(|(peer_id, conn), _| (peer_id, StreamMuxerBox::new(conn))))
        })
        .map_err(|e| ServiceError::Swarm(format!("WebRTC transport error: {}", e)))?
        .with_behaviour(|_| behaviour)
        .map_err(|e| ServiceError::Swarm(format!("Failed to create behaviour: {}", e)))?
        .with_swarm_config(|cfg| cfg.with_idle_connection_timeout(config.connection_timeout))
        .build()
} else {
    swarm_builder
        .with_behaviour(|_| behaviour)
        .map_err(|e| ServiceError::Swarm(format!("Failed to create behaviour: {}", e)))?
        .with_swarm_config(|cfg| cfg.with_idle_connection_timeout(config.connection_timeout))
        .build()
};
```

4. In the start() method (around line 458), add WebRTC listener after TCP/QUIC listeners:
```rust
// Start WebRTC listener if enabled
if self.config.enable_webrtc {
    let webrtc_addr: Multiaddr =
        format!("/ip4/0.0.0.0/udp/{}/webrtc-direct", self.config.webrtc_port)
            .parse()
            .map_err(|e| ServiceError::Transport(format!("Invalid WebRTC address: {}", e)))?;

    self.swarm
        .listen_on(webrtc_addr.clone())
        .map_err(|e| ServiceError::Transport(format!("Failed to listen on WebRTC: {}", e)))?;

    info!(
        "P2P service listening on {} (WebRTC) for browser connections",
        webrtc_addr
    );
}
```

5. In the start() method, after NAT configuration (around line 470), add external address advertisement:
```rust
// Advertise external WebRTC address if configured (for NAT/Docker environments)
if let Some(ref external_addr_str) = self.config.external_address {
    match external_addr_str.parse::<Multiaddr>() {
        Ok(external_addr) => {
            self.swarm.add_external_address(external_addr.clone());
            info!("Advertising external address: {}", external_addr);
        }
        Err(e) => {
            warn!("Invalid external address '{}': {}", external_addr_str, e);
        }
    }
}
```

6. Add WebRTC connection logging in the event loop. In the SwarmEvent::NewListenAddr handler, enhance the logging:
```rust
SwarmEvent::NewListenAddr { address, .. } => {
    // Log with emphasis if it's a WebRTC address (contains certhash)
    if address.to_string().contains("webrtc") {
        info!("WebRTC listening address (for browsers): {}", address);
    } else {
        event_handler::handle_new_listen_addr(&address);
    }
}
```
  </action>
  <verify>
`cargo check -p nsn-p2p` compiles without errors. The SwarmBuilder chain should compile with conditional WebRTC transport.
  </verify>
  <done>
P2pService conditionally adds WebRTC transport when config.enable_webrtc is true. Certificate is loaded, transport is added, WebRTC listener is started on configured port.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add CLI flags for WebRTC configuration</name>
  <files>
    node-core/bin/nsn-node/src/main.rs
  </files>
  <action>
Add CLI arguments for WebRTC configuration to the nsn-node binary.

1. Add the following fields to the Cli struct (after line 78, near the other p2p flags):
```rust
/// Enable WebRTC transport for browser connections
#[arg(long)]
p2p_enable_webrtc: bool,

/// UDP port for WebRTC connections (default: 9003)
#[arg(long, default_value = "9003")]
p2p_webrtc_port: u16,

/// External address to advertise for WebRTC (for NAT/Docker)
/// Format: /ip4/1.2.3.4/udp/9003/webrtc-direct
#[arg(long)]
p2p_external_address: Option<String>,

/// Data directory for persistent state (certificates, etc.)
#[arg(long, default_value = "/var/lib/nsn")]
data_dir: PathBuf,
```

2. Update the P2pConfig construction (around line 219) to use the new CLI flags:
```rust
// Initialize P2P networking
let mut p2p_config = P2pConfig::default();
p2p_config.listen_port = cli.p2p_listen_port;
p2p_config.metrics_port = cli.p2p_metrics_port;
p2p_config.keypair_path = cli.p2p_keypair_path.clone();
p2p_config.enable_webrtc = cli.p2p_enable_webrtc;
p2p_config.webrtc_port = cli.p2p_webrtc_port;
p2p_config.data_dir = Some(cli.data_dir.clone());
p2p_config.external_address = cli.p2p_external_address.clone();
```

3. Add info logging after P2P service creation to show WebRTC status:
```rust
if cli.p2p_enable_webrtc {
    info!(
        "WebRTC transport enabled on UDP port {}, data dir: {:?}",
        cli.p2p_webrtc_port, cli.data_dir
    );
    if let Some(ref addr) = cli.p2p_external_address {
        info!("External address for WebRTC: {}", addr);
    }
}
```

4. Add std::path::PathBuf to the imports if not already present.
  </action>
  <verify>
`cargo build -p nsn-node` compiles. `./target/debug/nsn-node --help` shows the new WebRTC flags.
  </verify>
  <done>
CLI accepts --p2p-enable-webrtc, --p2p-webrtc-port, --p2p-external-address, and --data-dir flags. Flags are wired to P2pConfig.
  </done>
</task>

<task type="auto">
  <name>Task 3: Add integration test for WebRTC transport</name>
  <files>
    node-core/crates/p2p/src/service.rs
  </files>
  <action>
Add a test to verify WebRTC transport can be enabled and the swarm builds correctly.

Add to the tests module in service.rs:

```rust
#[tokio::test]
async fn test_service_with_webrtc_enabled() {
    use tempfile::TempDir;

    let temp_dir = TempDir::new().expect("Failed to create temp dir");

    let mut config = P2pConfig {
        enable_webrtc: true,
        webrtc_port: 19003, // Use non-standard port for test
        data_dir: Some(temp_dir.path().to_path_buf()),
        ..Default::default()
    };
    config.bootstrap.require_signed_manifests = false;
    config.bootstrap.signer_config.source = crate::SignerSource::Static;

    let result = P2pService::new(config, "ws://127.0.0.1:9944".to_string()).await;

    // Service should create successfully with WebRTC enabled
    assert!(result.is_ok(), "Service should create with WebRTC enabled: {:?}", result.err());

    let (service, _cmd_tx) = result.unwrap();

    // Verify local peer ID exists
    assert!(!service.local_peer_id().to_string().is_empty());

    // Verify certificate was created
    let cert_path = temp_dir.path().join("webrtc_cert.pem");
    assert!(cert_path.exists(), "WebRTC certificate should be created");
}

#[tokio::test]
async fn test_webrtc_certificate_persists() {
    use tempfile::TempDir;

    let temp_dir = TempDir::new().expect("Failed to create temp dir");
    let cert_path = temp_dir.path().join("webrtc_cert.pem");

    // Create first service - should generate certificate
    {
        let mut config = P2pConfig {
            enable_webrtc: true,
            webrtc_port: 19004,
            data_dir: Some(temp_dir.path().to_path_buf()),
            ..Default::default()
        };
        config.bootstrap.require_signed_manifests = false;
        config.bootstrap.signer_config.source = crate::SignerSource::Static;

        let _ = P2pService::new(config, "ws://127.0.0.1:9944".to_string()).await;
    }

    // Read certificate content
    let cert_content_1 = std::fs::read_to_string(&cert_path)
        .expect("Should read certificate");

    // Create second service - should load existing certificate
    {
        let mut config = P2pConfig {
            enable_webrtc: true,
            webrtc_port: 19005,
            data_dir: Some(temp_dir.path().to_path_buf()),
            ..Default::default()
        };
        config.bootstrap.require_signed_manifests = false;
        config.bootstrap.signer_config.source = crate::SignerSource::Static;

        let _ = P2pService::new(config, "ws://127.0.0.1:9944".to_string()).await;
    }

    // Certificate content should be unchanged
    let cert_content_2 = std::fs::read_to_string(&cert_path)
        .expect("Should read certificate");

    assert_eq!(
        cert_content_1, cert_content_2,
        "Certificate should persist across service instances"
    );
}
```

Note: These tests use high port numbers (19003, 19004, 19005) to avoid conflicts with other tests.
  </action>
  <verify>
`cargo test -p nsn-p2p test_service_with_webrtc` passes. `cargo test -p nsn-p2p test_webrtc_certificate_persists` passes.
  </verify>
  <done>
Integration tests verify WebRTC transport can be enabled and certificates persist across restarts.
  </done>
</task>

</tasks>

<verification>
Run the following to verify all plan objectives are met:

```bash
# 1. Build the full node binary
cargo build -p nsn-node

# 2. Verify CLI flags exist
./target/debug/nsn-node super-node --help | grep -E "(webrtc|data-dir|external-address)"

# 3. Run all p2p tests
cargo test -p nsn-p2p

# 4. Verify WebRTC-specific tests pass
cargo test -p nsn-p2p webrtc

# 5. Quick manual test (start node with WebRTC enabled)
# Note: This will fail to connect to chain but should show WebRTC listening
timeout 5 ./target/debug/nsn-node super-node \
    --p2p-enable-webrtc \
    --p2p-webrtc-port 9003 \
    --data-dir /tmp/nsn-test \
    --log-level debug 2>&1 | grep -i webrtc || true
```
</verification>

<success_criteria>
1. `cargo build -p nsn-node` succeeds
2. CLI shows --p2p-enable-webrtc, --p2p-webrtc-port, --p2p-external-address, --data-dir flags
3. `cargo test -p nsn-p2p` passes all tests including new WebRTC tests
4. When started with --p2p-enable-webrtc, node logs "WebRTC listening address" with certhash
5. Certificate file persists at configured data_dir/webrtc_cert.pem
6. External address is advertised when --p2p-external-address is provided
</success_criteria>

<output>
After completion, create `.planning/phases/01-rust-node-core-upgrade/01-02-SUMMARY.md`
</output>
