---
phase: 03-viewer-implementation
plan: 03
type: execute
wave: 3
depends_on: ["03-02"]
files_modified:
  - viewer/src/services/p2pClient.ts
  - viewer/src/services/videoPipeline.ts
autonomous: true

must_haves:
  truths:
    - "GossipSub messages on /nsn/video/1.0.0 trigger chunk processing"
    - "Decoded chunks are fed to existing video pipeline"
  artifacts:
    - path: "viewer/src/services/p2pClient.ts"
      provides: "Extended P2P client with video subscription"
      exports: ["P2PClient"]
      contains: "/nsn/video/1.0.0"
    - path: "viewer/src/services/videoPipeline.ts"
      provides: "Video pipeline with P2P chunk adapter"
      min_lines: 180
  key_links:
    - from: "viewer/src/services/p2pClient.ts"
      to: "GossipSub pubsub"
      via: "node.services.pubsub.subscribe"
      pattern: "pubsub\\.subscribe"
    - from: "viewer/src/services/videoPipeline.ts"
      to: "viewer/src/services/videoCodec.ts"
      via: "import decodeVideoChunk"
      pattern: "decodeVideoChunk"
---

<objective>
Wire GossipSub subscription to video topic and connect decoded chunks to the existing video pipeline.

Purpose: Complete the data path from P2P network to video rendering.
Output: GossipSub subscription active, chunks decoded and fed to video buffer.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/03-viewer-implementation/03-CONTEXT.md
@.planning/phases/03-viewer-implementation/03-RESEARCH.md
@.planning/phases/03-viewer-implementation/03-01-SUMMARY.md
@.planning/phases/03-viewer-implementation/03-02-SUMMARY.md

# Existing video pipeline to integrate with
@viewer/src/services/videoPipeline.ts
@viewer/src/services/videoBuffer.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add video subscription to P2PClient</name>
  <files>viewer/src/services/p2pClient.ts</files>
  <action>
Extend P2PClient with video-specific subscription method.

**Add constant:**
```typescript
const VIDEO_TOPIC = '/nsn/video/1.0.0';
```

**Add method to P2PClient class:**

`subscribeToVideoTopic(handler: (data: Uint8Array) => void): void`
- Check node is initialized (throw if not)
- Call `this.node.services.pubsub.subscribe(VIDEO_TOPIC)`
- Add event listener: `this.node.services.pubsub.addEventListener('message', callback)`
- In callback:
  - Check `evt.detail.topic === VIDEO_TOPIC`
  - Call `handler(new Uint8Array(evt.detail.data))` (ensure Uint8Array)
- Store cleanup reference for later unsubscribe

**Add method:**
`unsubscribeFromVideoTopic(): void`
- Remove event listener
- Call `this.node.services.pubsub.unsubscribe(VIDEO_TOPIC)`

**Update stop() method:**
- Call unsubscribeFromVideoTopic() before stopping node

**Add exports:**
- Export `VIDEO_TOPIC` constant
  </action>
  <verify>
- `pnpm typecheck` passes
- `pnpm lint` passes
- P2PClient has subscribeToVideoTopic and unsubscribeFromVideoTopic methods
  </verify>
  <done>
P2PClient subscribes to /nsn/video/1.0.0 GossipSub topic and delivers raw bytes to handler.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create P2P chunk adapter for video pipeline</name>
  <files>viewer/src/services/videoPipeline.ts</files>
  <action>
Add adapter function to connect P2PClient to VideoPipeline.

**Add imports at top:**
```typescript
import { decodeVideoChunk, type DecodedVideoChunk } from './videoCodec';
import type { P2PClient } from './p2pClient';
```

**Add adapter function (module level, after VideoPipeline class):**

```typescript
/**
 * Connect P2P client to video pipeline for chunk delivery.
 * Decodes SCALE-encoded chunks and feeds to pipeline buffer.
 */
export function connectP2PToPipeline(
  p2pClient: P2PClient,
  pipeline: VideoPipeline
): void {
  p2pClient.subscribeToVideoTopic((data: Uint8Array) => {
    try {
      const chunk = decodeVideoChunk(data);

      // Adapt DecodedVideoChunk to VideoChunkMessage format
      pipeline.handleIncomingChunk({
        slot: Number(chunk.slot),
        chunk_index: chunk.chunkIndex,
        data: chunk.payload,
        timestamp: Number(chunk.timestampMs) * 1000, // ms to microseconds for WebCodecs
        is_keyframe: chunk.isKeyframe,
      });
    } catch (err) {
      console.error('Failed to decode video chunk:', err);
      // Don't crash pipeline on single bad chunk - silently drop
    }
  });
}
```

**Add stats tracking to VideoPipeline class:**

Add private property:
```typescript
private chunkStats: { receivedAt: number; size: number }[] = [];
```

Update handleIncomingChunk to record stats:
```typescript
// At start of handleIncomingChunk:
this.chunkStats.push({ receivedAt: Date.now(), size: message.data.length });
// Prune stats older than 10 seconds
const cutoff = Date.now() - 10000;
this.chunkStats = this.chunkStats.filter(s => s.receivedAt > cutoff);
```

Add method:
```typescript
/**
 * Calculate current bitrate in Mbps from recent chunks.
 */
getBitrateMbps(): number {
  if (this.chunkStats.length < 2) return 0;
  const now = Date.now();
  const windowMs = 5000; // 5 second window
  const recentStats = this.chunkStats.filter(s => now - s.receivedAt < windowMs);
  if (recentStats.length < 2) return 0;

  const totalBytes = recentStats.reduce((sum, s) => sum + s.size, 0);
  const totalBits = totalBytes * 8;
  const mbps = totalBits / windowMs / 1000; // bits/ms = kbps, /1000 = Mbps
  return Math.round(mbps * 100) / 100;
}
```

Add method:
```typescript
/**
 * Calculate latency from chunk timestamp to now.
 * Uses most recent chunk.
 */
getLatencyMs(): number {
  // This will be populated when we track chunk timestamps
  // For now return 0 - will be wired in Plan 04
  return 0;
}
```
  </action>
  <verify>
- `pnpm typecheck` passes
- `pnpm lint` passes
- connectP2PToPipeline function exported
- getBitrateMbps method exists on VideoPipeline
  </verify>
  <done>
P2P chunks are decoded and fed to video pipeline. Bitrate calculation from chunk sizes.
  </done>
</task>

</tasks>

<verification>
```bash
cd viewer
pnpm typecheck && pnpm lint && pnpm build
```

All commands pass. GossipSub subscription and pipeline adapter compile correctly.
</verification>

<success_criteria>
- P2PClient subscribes to /nsn/video/1.0.0 GossipSub topic
- connectP2PToPipeline() decodes SCALE chunks and feeds to pipeline
- VideoPipeline tracks chunk stats for bitrate calculation
- TypeScript compiles without errors
</success_criteria>

<output>
After completion, create `.planning/phases/03-viewer-implementation/03-03-SUMMARY.md`
</output>
