---
phase: 03-viewer-implementation
plan: 02
type: execute
wave: 2
depends_on: ["03-01"]
files_modified:
  - viewer/src/services/discovery.ts
  - viewer/src/services/videoCodec.ts
autonomous: true

must_haves:
  truths:
    - "Discovery fetches /p2p/info and extracts WebRTC multiaddr"
    - "SCALE-encoded VideoChunk can be decoded to TypeScript object"
  artifacts:
    - path: "viewer/src/services/discovery.ts"
      provides: "Node discovery and multiaddr extraction"
      exports: ["discoverNode", "discoverWithRace", "DiscoveryCandidate"]
      min_lines: 60
    - path: "viewer/src/services/videoCodec.ts"
      provides: "SCALE VideoChunk decoding"
      exports: ["decodeVideoChunk", "DecodedVideoChunk"]
      min_lines: 40
  key_links:
    - from: "viewer/src/services/discovery.ts"
      to: "HTTP /p2p/info"
      via: "fetch()"
      pattern: "fetch.*p2p/info"
    - from: "viewer/src/services/videoCodec.ts"
      to: "@polkadot/types"
      via: "TypeRegistry"
      pattern: "TypeRegistry"
---

<objective>
Create discovery service for HTTP-based node lookup and SCALE codec for VideoChunk decoding.

Purpose: Enable browser to find mesh nodes via HTTP discovery and decode binary video messages.
Output: Working discovery with parallel race pattern, working SCALE decoder matching Rust VideoChunk struct.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/03-viewer-implementation/03-CONTEXT.md
@.planning/phases/03-viewer-implementation/03-RESEARCH.md

# Reference Rust types for SCALE decoding
@node-core/crates/types/src/lib.rs (lines 210-242 for VideoChunk/VideoChunkHeader)

# Reference Phase 2 P2P info response format
@node-core/crates/p2p/src/discovery.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create discovery service</name>
  <files>viewer/src/services/discovery.ts</files>
  <action>
Create the discovery service for finding mesh nodes via HTTP.

**P2pInfoResponse interface** (matching Rust response):
```typescript
interface P2pInfoResponse {
  success: boolean;
  data?: {
    peer_id: string;
    multiaddrs: string[];
    protocols: string[];
    features: {
      webrtc_enabled: boolean;
      role: string;
    };
  };
  error?: {
    code: string;
    message: string;
  };
}
```

**DiscoveryCandidate interface**:
```typescript
export interface DiscoveryCandidate {
  url: string;
  source: 'localStorage' | 'settings' | 'env' | 'hardcoded';
}
```

**Exports:**

1. `discoverNode(baseUrl: string): Promise<string | null>`:
   - Fetch `${baseUrl}/p2p/info`
   - Handle 503 (return null for retry)
   - Parse JSON response
   - Find multiaddr containing `/webrtc-direct/` AND `/certhash/`
   - If WebRTC multiaddr found but missing `/p2p/<peer_id>`, append it
   - Return null if no WebRTC address available (caller treats as failure per CONTEXT.md)

2. `discoverWithRace(candidates: DiscoveryCandidate[], batchSize?: number, timeoutMs?: number): Promise<string>`:
   - Default batchSize: 3, timeoutMs: 3000
   - Shuffle hardcoded entries (per CONTEXT.md: avoid hammering first node)
   - Process in batches
   - Race each batch with timeout
   - First valid response wins
   - On success, save to `localStorage.setItem('last_known_node', url)`
   - Throw if all candidates fail

3. `buildCandidateList(): DiscoveryCandidate[]`:
   - Priority order per CONTEXT.md:
     1. `localStorage.getItem('last_known_node')` (if exists)
     2. User settings (placeholder for future)
     3. `import.meta.env.VITE_BOOTSTRAP_NODES` (comma-separated)
     4. Hardcoded defaults: `['http://localhost:9615']` (testnet only)

**Error handling:**
- Network errors return null (caller retries)
- 503 returns null with console.log about node initializing
- Non-WebRTC response treated as failure (per CONTEXT.md)
  </action>
  <verify>
- `pnpm typecheck` passes
- `pnpm lint` passes
- File exports discoverNode, discoverWithRace, buildCandidateList
  </verify>
  <done>
Discovery service fetches /p2p/info, extracts WebRTC multiaddr, implements parallel race pattern with localStorage persistence.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create SCALE VideoChunk codec</name>
  <files>viewer/src/services/videoCodec.ts</files>
  <action>
Create SCALE decoder for VideoChunk matching the Rust struct definition.

**VideoChunkHeader fields (MUST match Rust order exactly):**
```
version: u16
slot: u64
content_id: Text (String)
chunk_index: u32
total_chunks: u32
timestamp_ms: u64
is_keyframe: bool
payload_hash: [u8; 32]
```

**VideoChunk fields (MUST match Rust order exactly):**
```
header: VideoChunkHeader
payload: Bytes (Vec<u8>)
signer: Bytes (Vec<u8>)
signature: Bytes (Vec<u8>)
```

**Implementation:**

1. Create TypeRegistry ONCE at module level (do NOT create per decode)

2. Register types:
```typescript
import { TypeRegistry } from '@polkadot/types';

const registry = new TypeRegistry();
registry.register({
  VideoChunkHeader: {
    version: 'u16',
    slot: 'u64',
    content_id: 'Text',
    chunk_index: 'u32',
    total_chunks: 'u32',
    timestamp_ms: 'u64',
    is_keyframe: 'bool',
    payload_hash: '[u8; 32]',
  },
  VideoChunk: {
    header: 'VideoChunkHeader',
    payload: 'Bytes',
    signer: 'Bytes',
    signature: 'Bytes',
  },
});
```

3. Export `DecodedVideoChunk` interface:
```typescript
export interface DecodedVideoChunk {
  slot: bigint;
  chunkIndex: number;
  totalChunks: number;
  timestampMs: bigint;
  isKeyframe: boolean;
  payload: Uint8Array;
  contentId: string;
  version: number;
  payloadHash: Uint8Array;
}
```

4. Export `decodeVideoChunk(data: Uint8Array): DecodedVideoChunk`:
   - Use `registry.createType('VideoChunk', data)`
   - Convert to JSON then extract fields
   - Convert Bytes fields to Uint8Array
   - Return typed object

**Error handling:**
- Wrap in try/catch
- Re-throw with descriptive message on decode failure
  </action>
  <verify>
- `pnpm typecheck` passes
- `pnpm lint` passes
- File exports decodeVideoChunk, DecodedVideoChunk
  </verify>
  <done>
SCALE codec decodes VideoChunk binary to TypeScript object with correct field ordering matching Rust struct.
  </done>
</task>

</tasks>

<verification>
```bash
cd viewer
pnpm typecheck && pnpm lint && pnpm build
```

All commands pass. discovery.ts and videoCodec.ts compile correctly.
</verification>

<success_criteria>
- discovery.ts fetches /p2p/info and extracts WebRTC multiaddr with certhash
- discovery.ts implements parallel race pattern with 3-node batches
- discovery.ts saves last known good to localStorage
- videoCodec.ts decodes SCALE VideoChunk with correct field order
- TypeScript compiles without errors
</success_criteria>

<output>
After completion, create `.planning/phases/03-viewer-implementation/03-02-SUMMARY.md`
</output>
