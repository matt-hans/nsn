---
phase: 03-viewer-implementation
plan: 05
type: execute
wave: 4
depends_on: ["03-03", "03-04"]
files_modified:
  - viewer/src/services/p2p.ts
  - viewer/src/services/signaling.ts
  - viewer/src/App.tsx
  - viewer/src/components/TopBar.tsx
  - viewer/src/components/VideoPlayer/index.tsx
autonomous: false

must_haves:
  truths:
    - "Mock video stream code is completely removed"
    - "Signaling service is deleted"
    - "App renders bootstrap overlay during connection"
    - "NetworkStatus widget visible in UI"
  artifacts:
    - path: "viewer/src/App.tsx"
      provides: "Updated app with P2P integration"
      contains: "useP2PConnection"
    - path: "viewer/src/components/TopBar.tsx"
      provides: "TopBar with NetworkStatus widget"
      contains: "NetworkStatus"
  key_links:
    - from: "viewer/src/App.tsx"
      to: "viewer/src/hooks/useP2PConnection.ts"
      via: "import useP2PConnection"
      pattern: "useP2PConnection"
    - from: "viewer/src/components/TopBar.tsx"
      to: "viewer/src/components/NetworkStatus.tsx"
      via: "import NetworkStatus"
      pattern: "NetworkStatus"
---

<objective>
Remove mock video code, delete signaling service, integrate P2P into app, and add bootstrap UI.

Purpose: Complete the transformation from mock/signaling architecture to real P2P mesh.
Output: Clean codebase with working P2P integration and bootstrap UX.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/03-viewer-implementation/03-CONTEXT.md
@.planning/phases/03-viewer-implementation/03-RESEARCH.md
@.planning/phases/03-viewer-implementation/03-01-SUMMARY.md
@.planning/phases/03-viewer-implementation/03-02-SUMMARY.md
@.planning/phases/03-viewer-implementation/03-03-SUMMARY.md
@.planning/phases/03-viewer-implementation/03-04-SUMMARY.md

# Files to modify/delete
@viewer/src/services/p2p.ts
@viewer/src/services/signaling.ts
@viewer/src/App.tsx
@viewer/src/components/TopBar.tsx
@viewer/src/components/VideoPlayer/index.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Remove mock video and delete signaling</name>
  <files>
    viewer/src/services/p2p.ts
    viewer/src/services/signaling.ts
    viewer/src/services/__tests__/signaling.test.ts
    viewer/src/services/__tests__/p2p-service.test.ts
    viewer/src/services/p2p.test.ts
  </files>
  <action>
**Delete the following files entirely:**
- `viewer/src/services/signaling.ts`
- `viewer/src/services/__tests__/signaling.test.ts`
- `viewer/src/services/__tests__/p2p-service.test.ts`

**Rewrite p2p.ts as a thin compatibility layer:**

The new p2p.ts should re-export from p2pClient.ts for backward compatibility:

```typescript
// ICN Viewer Client - P2P Service (Compatibility Layer)
// Re-exports from p2pClient.ts for backward compatibility

export { P2PClient, VIDEO_TOPIC } from './p2pClient';
export type { VideoChunkMessage } from './videoPipeline';

// Legacy exports - these functions delegate to P2PClient
import { P2PClient } from './p2pClient';
import { buildCandidateList, discoverWithRace } from './discovery';

let sharedClient: P2PClient | null = null;

export function getP2PService(): P2PClient {
  if (!sharedClient) {
    sharedClient = new P2PClient();
  }
  return sharedClient;
}

export async function connectToMesh(): Promise<boolean> {
  try {
    const client = getP2PService();
    await client.initialize();
    const candidates = buildCandidateList();
    const multiaddr = await discoverWithRace(candidates);
    await client.dial(multiaddr);
    return true;
  } catch (error) {
    console.error('Failed to connect to mesh:', error);
    return false;
  }
}

export function disconnect(): void {
  if (sharedClient) {
    sharedClient.stop();
    sharedClient = null;
  }
}

export function getConnectionStatus(): boolean {
  return sharedClient?.isStarted() ?? false;
}

// REMOVED: startMockVideoStream - no more mocks
// REMOVED: All simple-peer and signaling related code
```

**Delete p2p.test.ts** (will need new tests for p2pClient.ts later):
- The old tests rely on simple-peer mocks that no longer exist

Note: Per CONTEXT.md "Mock Removal Strategy", we do direct replacement with no feature flags.
  </action>
  <verify>
- `rm` commands succeed for deleted files
- `pnpm typecheck` passes
- `pnpm lint` passes
- No references to SignalingClient, simple-peer, or startMockVideoStream
  </verify>
  <done>
Mock video generator removed, signaling service deleted, p2p.ts reduced to compatibility layer.
  </done>
</task>

<task type="auto">
  <name>Task 2: Integrate P2P into App and add bootstrap overlay</name>
  <files>
    viewer/src/App.tsx
    viewer/src/components/TopBar.tsx
    viewer/src/components/VideoPlayer/index.tsx
  </files>
  <action>
**Update App.tsx:**

Add P2P connection initialization on mount:

```typescript
import { useEffect } from 'react';
import { useP2PConnection } from './hooks/useP2PConnection';
import { useAppStore } from './store/appStore';
import { BootstrapOverlay } from './components/BootstrapOverlay';
// ... existing imports

export function App() {
  const { connect, isConnected, isConnecting } = useP2PConnection();
  const { bootstrapProgress, connectionStatus } = useAppStore();

  // Auto-connect on mount
  useEffect(() => {
    connect();
  }, [connect]);

  // Show full-screen overlay during bootstrap (per CONTEXT.md)
  const showBootstrapOverlay = connectionStatus !== 'connected' && connectionStatus !== 'disconnected';

  return (
    <>
      {showBootstrapOverlay && <BootstrapOverlay />}
      <AppShell />
    </>
  );
}
```

**Create BootstrapOverlay component** at `viewer/src/components/BootstrapOverlay.tsx`:

Per CONTEXT.md two-phase bootstrap UX:

```typescript
import React, { useEffect, useState } from 'react';
import { useAppStore } from '../store/appStore';

export function BootstrapOverlay() {
  const { bootstrapProgress, connectionError } = useAppStore();
  const [showManual, setShowManual] = useState(false);

  // After 30s in error/connecting state, show manual option
  useEffect(() => {
    if (bootstrapProgress.startedAt) {
      const elapsed = Date.now() - bootstrapProgress.startedAt;
      if (elapsed > 30000 && bootstrapProgress.phase === 'error') {
        setShowManual(true);
      }
    }
  }, [bootstrapProgress]);

  // Progressive messaging per CONTEXT.md
  const getMessage = (): string => {
    switch (bootstrapProgress.phase) {
      case 'discovering':
        return 'Connecting to Swarm...';
      case 'connecting':
        return bootstrapProgress.message || 'Negotiating NAT traversal...';
      case 'subscribing':
        return 'Joining video channel...';
      case 'error':
        return connectionError || 'Unable to join the Neural Sovereign Network';
      default:
        return 'Initializing...';
    }
  };

  return (
    <div className="fixed inset-0 z-50 bg-black flex flex-col items-center justify-center">
      {/* Terminal-style aesthetic */}
      <div className="text-center space-y-6 max-w-md px-4">
        {/* Animated loader */}
        <div className="w-16 h-16 mx-auto border-4 border-green-500 border-t-transparent rounded-full animate-spin" />

        {/* Status message */}
        <p className="text-green-500 font-mono text-lg">{getMessage()}</p>

        {/* Error state buttons */}
        {bootstrapProgress.phase === 'error' && (
          <div className="space-y-3 mt-8">
            <button
              onClick={() => window.location.reload()}
              className="w-full px-6 py-3 bg-green-600 hover:bg-green-500 text-white rounded-lg font-medium transition"
            >
              Retry
            </button>
            {showManual && (
              <button
                onClick={() => {
                  // Will be connected to settings modal later
                  console.log('Open manual bootstrap');
                }}
                className="w-full px-6 py-3 bg-gray-700 hover:bg-gray-600 text-white rounded-lg font-medium transition"
              >
                Try Manual Bootstrap
              </button>
            )}
          </div>
        )}

        {/* Expandable diagnostics for errors */}
        {bootstrapProgress.phase === 'error' && connectionError && (
          <details className="text-left text-gray-400 text-sm mt-4">
            <summary className="cursor-pointer hover:text-gray-300">[+] View Network Diagnostics</summary>
            <pre className="mt-2 p-3 bg-gray-900 rounded font-mono text-xs overflow-auto">
              {connectionError}
            </pre>
          </details>
        )}
      </div>
    </div>
  );
}
```

**Update TopBar.tsx:**

Add NetworkStatus widget in top-right:

```typescript
import { NetworkStatus } from './NetworkStatus';
// ... existing imports

// In the TopBar component JSX, add NetworkStatus to the right side:
<div className="flex items-center gap-4">
  <NetworkStatus className="mr-2" />
  {/* existing buttons */}
</div>
```

**Update VideoPlayer/index.tsx:**

Remove any mock video initialization. Update to use pipeline from P2P:

1. Remove any calls to `startMockVideoStream`
2. Remove any direct connections to old P2P service
3. The video pipeline will receive chunks via connectP2PToPipeline() in useP2PConnection

Look for and remove patterns like:
- `startMockVideoStream(slot)`
- `onVideoChunk(handler)`
- Direct SignalingClient usage
  </action>
  <verify>
- `pnpm typecheck` passes
- `pnpm lint` passes
- `pnpm build` succeeds
- App.tsx imports useP2PConnection
- TopBar.tsx includes NetworkStatus
- No startMockVideoStream calls anywhere
  </verify>
  <done>
App auto-connects on mount, shows bootstrap overlay during connection, NetworkStatus in TopBar.
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>
Complete P2P mesh integration for viewer:
- libp2p WebRTC-Direct transport
- HTTP discovery with race pattern
- SCALE VideoChunk decoding
- GossipSub subscription to video topic
- Connection state management
- Bootstrap overlay UI
- NetworkStatus widget
- Mock video code removed
  </what-built>
  <how-to-verify>
1. Start a Rust mesh node with WebRTC enabled:
   ```bash
   cd node-core && cargo run --release -p nsn-node -- --dev --p2p-enable-webrtc
   ```

2. Start the viewer in development mode:
   ```bash
   cd viewer && pnpm dev
   ```

3. Open http://localhost:5173 in browser

4. **Bootstrap UX verification:**
   - Should see full-screen bootstrap overlay
   - Message should progress: "Connecting to Swarm..." -> "Finding mesh nodes..." -> etc.
   - If node not running, should show error with Retry button

5. **Connection verification (with node running):**
   - Bootstrap overlay should disappear on success
   - NetworkStatus widget should appear in top-right
   - Should show green dot with "Mesh Active (N peers)"
   - Hover should show peer ID and "WebRTC-Direct" protocol

6. **Console check:**
   - No errors about simple-peer or signaling
   - Should see libp2p connection logs

7. **Reconnection test:**
   - Stop the Rust node
   - NetworkStatus should change to yellow/red
   - Restart node
   - Should auto-reconnect (check console for "Scheduling reconnect...")

8. **Code cleanup verification:**
   ```bash
   grep -r "startMockVideoStream" viewer/src/
   grep -r "SignalingClient" viewer/src/
   grep -r "simple-peer" viewer/src/
   ```
   All three should return no results.
  </how-to-verify>
  <resume-signal>Type "approved" or describe issues found</resume-signal>
</task>

</tasks>

<verification>
```bash
cd viewer
pnpm typecheck && pnpm lint && pnpm build

# Verify no mock/signaling references
grep -r "startMockVideoStream" src/ || echo "OK: No mock references"
grep -r "SignalingClient" src/ || echo "OK: No signaling references"
grep -r "simple-peer" src/ || echo "OK: No simple-peer references"
```

All commands pass. No mock or signaling code remains.
</verification>

<success_criteria>
- Mock video stream completely removed
- Signaling service deleted
- App integrates P2P on mount
- Bootstrap overlay shows during connection
- NetworkStatus widget in TopBar
- Human verification confirms working connection
</success_criteria>

<output>
After completion, create `.planning/phases/03-viewer-implementation/03-05-SUMMARY.md`
</output>
