---
phase: 03-viewer-implementation
plan: 04
type: execute
wave: 3
depends_on: ["03-02"]
files_modified:
  - viewer/src/store/appStore.ts
  - viewer/src/hooks/useP2PConnection.ts
  - viewer/src/components/NetworkStatus.tsx
autonomous: true

must_haves:
  truths:
    - "Connection state tracked in Zustand store"
    - "Network health widget shows connected/disconnected status"
    - "Reconnection attempts with exponential backoff"
  artifacts:
    - path: "viewer/src/store/appStore.ts"
      provides: "Extended app state with P2P connection details"
      contains: "connectedPeerId"
    - path: "viewer/src/hooks/useP2PConnection.ts"
      provides: "React hook for P2P lifecycle"
      exports: ["useP2PConnection"]
      min_lines: 80
    - path: "viewer/src/components/NetworkStatus.tsx"
      provides: "Network health indicator widget"
      exports: ["NetworkStatus"]
      min_lines: 50
  key_links:
    - from: "viewer/src/hooks/useP2PConnection.ts"
      to: "viewer/src/services/p2pClient.ts"
      via: "import P2PClient"
      pattern: "P2PClient"
    - from: "viewer/src/hooks/useP2PConnection.ts"
      to: "viewer/src/services/discovery.ts"
      via: "import discoverWithRace"
      pattern: "discoverWithRace"
---

<objective>
Create connection state management, React hook for P2P lifecycle, and network status widget.

Purpose: Enable UI to reflect connection state and provide user feedback per CONTEXT.md UX decisions.
Output: Connection state in Zustand, useP2PConnection hook with reconnection, NetworkStatus widget.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/03-viewer-implementation/03-CONTEXT.md
@.planning/phases/03-viewer-implementation/03-RESEARCH.md
@.planning/phases/03-viewer-implementation/03-01-SUMMARY.md
@.planning/phases/03-viewer-implementation/03-02-SUMMARY.md

# Existing store to extend
@viewer/src/store/appStore.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend Zustand store with P2P state</name>
  <files>viewer/src/store/appStore.ts</files>
  <action>
Extend the app store with detailed P2P connection state.

**Add new state properties to AppState interface:**
```typescript
// P2P connection details (new)
connectedPeerId: string | null;
meshPeerCount: number;
connectionError: string | null;
lastConnectedNodeUrl: string | null;
bootstrapProgress: {
  phase: 'idle' | 'discovering' | 'connecting' | 'subscribing' | 'ready' | 'error';
  message: string;
  startedAt: number | null;
};
```

**Add new actions to AppState interface:**
```typescript
setConnectedPeerId: (peerId: string | null) => void;
setMeshPeerCount: (count: number) => void;
setConnectionError: (error: string | null) => void;
setLastConnectedNodeUrl: (url: string | null) => void;
setBootstrapProgress: (phase: AppState['bootstrapProgress']['phase'], message: string) => void;
```

**Add initial state:**
```typescript
connectedPeerId: null,
meshPeerCount: 0,
connectionError: null,
lastConnectedNodeUrl: null,
bootstrapProgress: {
  phase: 'idle',
  message: '',
  startedAt: null,
},
```

**Add action implementations:**
```typescript
setConnectedPeerId: (peerId) => set({ connectedPeerId: peerId }),
setMeshPeerCount: (count) => set({ meshPeerCount: count }),
setConnectionError: (error) => set({ connectionError: error }),
setLastConnectedNodeUrl: (url) => set({ lastConnectedNodeUrl: url }),
setBootstrapProgress: (phase, message) => set({
  bootstrapProgress: {
    phase,
    message,
    startedAt: phase === 'discovering' ? Date.now() : get().bootstrapProgress.startedAt,
  },
}),
```

Note: Use `get()` in setBootstrapProgress - this requires using `(set, get) =>` form.

**Update persist partialize** to include lastConnectedNodeUrl:
```typescript
partialize: (state) => ({
  volume: state.volume,
  quality: state.quality,
  seedingEnabled: state.seedingEnabled,
  currentSlot: state.currentSlot,
  lastConnectedNodeUrl: state.lastConnectedNodeUrl, // NEW
}),
```
  </action>
  <verify>
- `pnpm typecheck` passes
- `pnpm lint` passes
- Store has new P2P state properties and actions
  </verify>
  <done>
Zustand store tracks P2P connection state including peer ID, mesh count, errors, and bootstrap progress.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create useP2PConnection hook</name>
  <files>viewer/src/hooks/useP2PConnection.ts</files>
  <action>
Create React hook that manages P2P connection lifecycle with reconnection.

**Imports:**
```typescript
import { useEffect, useRef, useCallback } from 'react';
import { useAppStore } from '../store/appStore';
import { P2PClient } from '../services/p2pClient';
import { buildCandidateList, discoverWithRace } from '../services/discovery';
import { connectP2PToPipeline, getVideoPipeline } from '../services/videoPipeline';
```

**Hook implementation:**

```typescript
export function useP2PConnection() {
  const p2pClientRef = useRef<P2PClient | null>(null);
  const reconnectTimeoutRef = useRef<number | null>(null);
  const reconnectAttemptRef = useRef(0);

  const {
    connectionStatus,
    setConnectionStatus,
    setConnectedPeerId,
    setMeshPeerCount,
    setConnectionError,
    setBootstrapProgress,
    setLastConnectedNodeUrl,
  } = useAppStore();

  const connect = useCallback(async () => {
    // Clear any pending reconnect
    if (reconnectTimeoutRef.current) {
      clearTimeout(reconnectTimeoutRef.current);
      reconnectTimeoutRef.current = null;
    }

    setConnectionStatus('connecting');
    setConnectionError(null);
    setBootstrapProgress('discovering', 'Connecting to Swarm...');

    try {
      // 1. Initialize P2P client
      const client = new P2PClient();
      await client.initialize();
      p2pClientRef.current = client;
      setConnectedPeerId(client.getPeerId());

      // 2. Discover a mesh node
      const candidates = buildCandidateList();
      setBootstrapProgress('connecting', 'Finding mesh nodes...');
      const multiaddr = await discoverWithRace(candidates);

      // 3. Dial the discovered node
      setBootstrapProgress('connecting', 'Negotiating NAT traversal...');
      await client.dial(multiaddr);

      // 4. Subscribe to video topic
      setBootstrapProgress('subscribing', 'Joining video channel...');
      const pipeline = getVideoPipeline();
      if (pipeline) {
        connectP2PToPipeline(client, pipeline);
      }

      // 5. Success
      setConnectionStatus('connected');
      setBootstrapProgress('ready', 'Mesh Active');
      setMeshPeerCount(client.getConnectedPeers());
      reconnectAttemptRef.current = 0;

    } catch (error) {
      const message = error instanceof Error ? error.message : 'Connection failed';
      console.error('P2P connection failed:', message);
      setConnectionStatus('error');
      setConnectionError(message);
      setBootstrapProgress('error', message);

      // Schedule reconnection with exponential backoff
      scheduleReconnect();
    }
  }, [setConnectionStatus, setConnectedPeerId, setMeshPeerCount, setConnectionError, setBootstrapProgress]);

  const scheduleReconnect = useCallback(() => {
    const attempt = reconnectAttemptRef.current;
    const delay = Math.min(1000 * Math.pow(2, attempt), 30000); // Max 30s
    reconnectAttemptRef.current = attempt + 1;

    console.log(`Scheduling reconnect in ${delay}ms (attempt ${attempt + 1})`);
    setBootstrapProgress('error', `Reconnecting in ${Math.ceil(delay / 1000)}s...`);

    reconnectTimeoutRef.current = window.setTimeout(() => {
      connect();
    }, delay);
  }, [connect, setBootstrapProgress]);

  const disconnect = useCallback(() => {
    if (reconnectTimeoutRef.current) {
      clearTimeout(reconnectTimeoutRef.current);
      reconnectTimeoutRef.current = null;
    }

    if (p2pClientRef.current) {
      p2pClientRef.current.stop();
      p2pClientRef.current = null;
    }

    setConnectionStatus('disconnected');
    setConnectedPeerId(null);
    setMeshPeerCount(0);
    setBootstrapProgress('idle', '');
  }, [setConnectionStatus, setConnectedPeerId, setMeshPeerCount, setBootstrapProgress]);

  // Cleanup on unmount
  useEffect(() => {
    return () => {
      disconnect();
    };
  }, [disconnect]);

  return {
    connect,
    disconnect,
    isConnected: connectionStatus === 'connected',
    isConnecting: connectionStatus === 'connecting',
    client: p2pClientRef.current,
  };
}
```
  </action>
  <verify>
- `pnpm typecheck` passes
- `pnpm lint` passes
- Hook exports useP2PConnection
  </verify>
  <done>
useP2PConnection hook manages full P2P lifecycle with discovery, connection, and exponential backoff reconnection.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create NetworkStatus widget</name>
  <files>viewer/src/components/NetworkStatus.tsx</files>
  <action>
Create the persistent network health indicator widget per CONTEXT.md.

**Component implementation:**

```typescript
import React from 'react';
import { useAppStore } from '../store/appStore';

interface NetworkStatusProps {
  className?: string;
}

export function NetworkStatus({ className = '' }: NetworkStatusProps) {
  const { connectionStatus, meshPeerCount, connectedPeerId, latency, bootstrapProgress } = useAppStore();

  // Determine status color and text
  let statusColor: string;
  let statusText: string;

  switch (connectionStatus) {
    case 'connected':
      if (meshPeerCount >= 3) {
        statusColor = 'bg-green-500';
        statusText = `Mesh Active (${meshPeerCount} peers)`;
      } else if (meshPeerCount > 0) {
        statusColor = 'bg-yellow-500';
        statusText = `Low Peers (${meshPeerCount})`;
      } else {
        statusColor = 'bg-yellow-500';
        statusText = 'Connected (0 peers)';
      }
      break;
    case 'connecting':
      statusColor = 'bg-yellow-500';
      statusText = bootstrapProgress.message || 'Connecting...';
      break;
    case 'error':
      statusColor = 'bg-red-500';
      statusText = 'Disconnected';
      break;
    case 'disconnected':
    default:
      statusColor = 'bg-gray-500';
      statusText = 'Disconnected';
      break;
  }

  // Truncate peer ID for display
  const shortPeerId = connectedPeerId ? `${connectedPeerId.slice(0, 8)}...` : null;

  return (
    <div className={`relative group ${className}`}>
      {/* Main indicator */}
      <div className="flex items-center gap-2 px-3 py-1.5 bg-black/60 rounded-lg cursor-default">
        <div className={`w-2 h-2 rounded-full ${statusColor} animate-pulse`} />
        <span className="text-white text-sm">{statusText}</span>
      </div>

      {/* Hover tooltip - expanded details */}
      {connectionStatus === 'connected' && (
        <div className="absolute right-0 top-full mt-1 hidden group-hover:block z-50">
          <div className="bg-black/90 text-white text-xs rounded-lg p-3 min-w-48 shadow-lg">
            <div className="space-y-1">
              <div>
                <span className="text-gray-400">Node: </span>
                <span className="font-mono">{shortPeerId || 'Unknown'}</span>
              </div>
              <div>
                <span className="text-gray-400">Latency: </span>
                <span>{latency > 0 ? `${latency}ms` : 'Measuring...'}</span>
              </div>
              <div>
                <span className="text-gray-400">Protocol: </span>
                <span>WebRTC-Direct</span>
              </div>
            </div>
          </div>
        </div>
      )}
    </div>
  );
}
```

This implements the CONTEXT.md spec:
- Green dot: Healthy (3+ peers)
- Yellow dot: Degraded (low peers, connecting)
- Red dot: Disconnected/error
- Hover tooltip with node ID, latency, protocol
  </action>
  <verify>
- `pnpm typecheck` passes
- `pnpm lint` passes
- Component exports NetworkStatus
  </verify>
  <done>
NetworkStatus widget shows connection health with color indicator and hover details per UX spec.
  </done>
</task>

</tasks>

<verification>
```bash
cd viewer
pnpm typecheck && pnpm lint && pnpm build
```

All commands pass. Store, hook, and component compile correctly.
</verification>

<success_criteria>
- Zustand store has P2P connection state (peerId, meshCount, error, progress)
- useP2PConnection hook manages lifecycle with exponential backoff
- NetworkStatus widget shows green/yellow/red indicator with hover details
- TypeScript compiles without errors
</success_criteria>

<output>
After completion, create `.planning/phases/03-viewer-implementation/03-04-SUMMARY.md`
</output>
