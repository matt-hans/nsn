---
phase: 02-discovery-bridge
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - node-core/crates/p2p/src/service.rs
  - node-core/crates/p2p/src/discovery.rs
  - node-core/crates/p2p/src/lib.rs
autonomous: true

must_haves:
  truths:
    - "Browser can fetch /p2p/info and receive JSON with peer_id and multiaddrs"
    - "Response includes WebRTC multiaddr with certhash when WebRTC is enabled"
    - "Response excludes internal Docker IPs (172.x.x.x) when external_address is configured"
    - "Response includes CORS headers allowing browser fetch from any origin"
    - "503 status with Retry-After:5 header returned when swarm not yet initialized"
    - "Response includes protocols list showing supported libp2p protocols"
  artifacts:
    - path: "node-core/crates/p2p/src/discovery.rs"
      provides: "P2P discovery endpoint types and address filtering"
      exports: ["P2pInfo", "P2pInfoError", "filter_addresses"]
      min_lines: 80
  key_links:
    - from: "node-core/crates/p2p/src/service.rs"
      to: "/p2p/info route"
      via: "hyper router match"
      pattern: '"/p2p/info"'
    - from: "node-core/crates/p2p/src/discovery.rs"
      to: "swarm.listeners"
      via: "address extraction"
      pattern: "Multiaddr"
---

<objective>
Add HTTP discovery endpoint for browsers to discover WebRTC connection details.

Purpose: Browsers need to know the node's peer_id, WebRTC multiaddr, and certhash to establish direct libp2p connections. This endpoint provides that bootstrap information on the existing HTTP server.

Output: Working `/p2p/info` endpoint on port 9615 (configurable via `--p2p-metrics-port`) that returns JSON with peer info, multiaddrs, protocols, and feature flags.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-discovery-bridge/02-CONTEXT.md

# Phase 1 summary for WebRTC context
@.planning/phases/01-rust-node-core-upgrade/01-02-SUMMARY.md

# Source files to modify
@node-core/crates/p2p/src/service.rs
@node-core/crates/p2p/src/config.rs
@node-core/crates/p2p/src/lib.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create discovery module with P2pInfo types and address filtering</name>
  <files>
    node-core/crates/p2p/src/discovery.rs
    node-core/crates/p2p/src/lib.rs
  </files>
  <action>
Create `node-core/crates/p2p/src/discovery.rs` with response types and address filtering logic.

```rust
//! P2P discovery endpoint types and utilities
//!
//! Provides the `/p2p/info` HTTP endpoint response format and address filtering
//! for browser discovery of WebRTC connection details.

use libp2p::{Multiaddr, PeerId};
use serde::{Deserialize, Serialize};
use std::net::IpAddr;
use thiserror::Error;

/// Discovery endpoint error types
#[derive(Debug, Error)]
pub enum P2pInfoError {
    #[error("Swarm not initialized")]
    SwarmNotReady,

    #[error("Serialization error: {0}")]
    Serialization(String),
}

/// Feature flags for the discovery response
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct P2pFeatures {
    /// Whether WebRTC transport is enabled
    pub webrtc_enabled: bool,

    /// Node role (director, validator, storage, supernode)
    pub role: String,
}

/// Discovery response data payload
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct P2pInfoData {
    /// Node's libp2p PeerId
    pub peer_id: String,

    /// Filtered multiaddrs (WebRTC with certhash prioritized)
    pub multiaddrs: Vec<String>,

    /// Supported libp2p protocols
    pub protocols: Vec<String>,

    /// Feature flags
    pub features: P2pFeatures,
}

/// Full discovery response envelope
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct P2pInfoResponse {
    /// Success flag
    pub success: bool,

    /// Response data (present on success)
    #[serde(skip_serializing_if = "Option::is_none")]
    pub data: Option<P2pInfoData>,

    /// Error details (present on failure)
    #[serde(skip_serializing_if = "Option::is_none")]
    pub error: Option<P2pInfoErrorPayload>,
}

/// Error payload for failed responses
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct P2pInfoErrorPayload {
    /// Error code (SNAKE_CASE)
    pub code: String,

    /// Human-readable message
    pub message: String,
}

impl P2pInfoResponse {
    /// Create a successful response
    pub fn success(data: P2pInfoData) -> Self {
        Self {
            success: true,
            data: Some(data),
            error: None,
        }
    }

    /// Create an error response
    pub fn error(code: &str, message: &str) -> Self {
        Self {
            success: false,
            data: None,
            error: Some(P2pInfoErrorPayload {
                code: code.to_string(),
                message: message.to_string(),
            }),
        }
    }
}

/// Filter multiaddrs for browser consumption.
///
/// Filtering rules (per CONTEXT.md Decision 4):
/// 1. If external_address is configured, return ONLY that address
/// 2. Otherwise, filter out IPv6 link-local addresses (fe80::/10)
/// 3. Keep localhost (127.x.x.x) for dev mode
/// 4. Keep RFC1918 private addresses (10.x, 172.16-31.x, 192.168.x)
///
/// # Arguments
/// * `listeners` - Iterator of listening multiaddrs from swarm
/// * `external_addrs` - Iterator of external addresses from swarm
/// * `external_override` - Optional configured external address (replaces all others)
pub fn filter_addresses<'a>(
    listeners: impl Iterator<Item = &'a Multiaddr>,
    external_addrs: impl Iterator<Item = &'a Multiaddr>,
    external_override: Option<&str>,
) -> Vec<String> {
    // If external address is configured, use ONLY that
    if let Some(ext) = external_override {
        if !ext.is_empty() {
            return vec![ext.to_string()];
        }
    }

    // Combine listeners and external addresses, prioritizing external
    let mut addrs: Vec<String> = external_addrs
        .chain(listeners)
        .filter(|addr| !is_link_local_ipv6(addr))
        .map(|addr| addr.to_string())
        .collect();

    // Deduplicate while preserving order
    let mut seen = std::collections::HashSet::new();
    addrs.retain(|addr| seen.insert(addr.clone()));

    addrs
}

/// Check if a multiaddr contains an IPv6 link-local address (fe80::/10)
fn is_link_local_ipv6(addr: &Multiaddr) -> bool {
    use libp2p::multiaddr::Protocol;

    for proto in addr.iter() {
        if let Protocol::Ip6(ip) = proto {
            // fe80::/10 - link-local unicast
            let segments = ip.segments();
            if (segments[0] & 0xffc0) == 0xfe80 {
                return true;
            }
        }
    }
    false
}

/// Check if a multiaddr is a WebRTC address
pub fn is_webrtc_address(addr: &str) -> bool {
    addr.contains("/webrtc") || addr.contains("/webrtc-direct")
}

/// Default protocols list for when swarm protocols aren't available
pub fn default_protocols() -> Vec<String> {
    vec![
        "/nsn/video/1.0.0".to_string(),
        "/ipfs/id/1.0.0".to_string(),
        "/ipfs/ping/1.0.0".to_string(),
    ]
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_success_response_format() {
        let data = P2pInfoData {
            peer_id: "12D3KooWExample".to_string(),
            multiaddrs: vec!["/ip4/1.2.3.4/udp/9003/webrtc-direct/certhash/uEiD...".to_string()],
            protocols: vec!["/nsn/video/1.0.0".to_string()],
            features: P2pFeatures {
                webrtc_enabled: true,
                role: "director".to_string(),
            },
        };

        let response = P2pInfoResponse::success(data);
        let json = serde_json::to_string(&response).expect("serialize");

        assert!(json.contains("\"success\":true"));
        assert!(json.contains("\"peer_id\""));
        assert!(json.contains("\"multiaddrs\""));
        assert!(json.contains("\"protocols\""));
        assert!(json.contains("\"webrtc_enabled\":true"));
        assert!(!json.contains("\"error\""));
    }

    #[test]
    fn test_success_response_has_protocols_field() {
        let data = P2pInfoData {
            peer_id: "12D3KooWExample".to_string(),
            multiaddrs: vec!["/ip4/1.2.3.4/udp/9003/webrtc-direct".to_string()],
            protocols: vec!["/nsn/video/1.0.0".to_string(), "/ipfs/id/1.0.0".to_string()],
            features: P2pFeatures {
                webrtc_enabled: true,
                role: "director".to_string(),
            },
        };

        let response = P2pInfoResponse::success(data);
        let json = serde_json::to_string(&response).expect("serialize");

        // Verify protocols field is present and contains expected values
        assert!(json.contains("\"protocols\""));
        assert!(json.contains("/nsn/video/1.0.0"));
        assert!(json.contains("/ipfs/id/1.0.0"));
    }

    #[test]
    fn test_error_response_format() {
        let response = P2pInfoResponse::error("NODE_INITIALIZING", "Swarm not ready");
        let json = serde_json::to_string(&response).expect("serialize");

        assert!(json.contains("\"success\":false"));
        assert!(json.contains("\"code\":\"NODE_INITIALIZING\""));
        assert!(json.contains("\"message\":\"Swarm not ready\""));
        assert!(!json.contains("\"data\""));
    }

    #[test]
    fn test_filter_external_override() {
        let listeners: Vec<Multiaddr> = vec![
            "/ip4/127.0.0.1/tcp/9000".parse().unwrap(),
            "/ip4/192.168.1.5/udp/9003/webrtc-direct".parse().unwrap(),
        ];

        let external: Vec<Multiaddr> = vec![];
        let override_addr = "/ip4/1.2.3.4/udp/9003/webrtc-direct";

        let result = filter_addresses(
            listeners.iter(),
            external.iter(),
            Some(override_addr),
        );

        assert_eq!(result.len(), 1);
        assert_eq!(result[0], override_addr);
    }

    #[test]
    fn test_filter_removes_link_local_ipv6() {
        let listeners: Vec<Multiaddr> = vec![
            "/ip6/fe80::1/tcp/9000".parse().unwrap(),
            "/ip4/127.0.0.1/tcp/9000".parse().unwrap(),
            "/ip6/2001:db8::1/tcp/9000".parse().unwrap(),
        ];

        let result = filter_addresses(listeners.iter(), std::iter::empty(), None);

        assert_eq!(result.len(), 2);
        assert!(result.iter().all(|a| !a.contains("fe80")));
        assert!(result.iter().any(|a| a.contains("127.0.0.1")));
        assert!(result.iter().any(|a| a.contains("2001:db8")));
    }

    #[test]
    fn test_filter_keeps_rfc1918() {
        let listeners: Vec<Multiaddr> = vec![
            "/ip4/10.0.0.1/tcp/9000".parse().unwrap(),
            "/ip4/172.16.0.1/tcp/9000".parse().unwrap(),
            "/ip4/192.168.1.1/tcp/9000".parse().unwrap(),
        ];

        let result = filter_addresses(listeners.iter(), std::iter::empty(), None);

        assert_eq!(result.len(), 3);
    }

    #[test]
    fn test_filter_deduplicates() {
        let listeners: Vec<Multiaddr> = vec![
            "/ip4/127.0.0.1/tcp/9000".parse().unwrap(),
        ];
        let external: Vec<Multiaddr> = vec![
            "/ip4/127.0.0.1/tcp/9000".parse().unwrap(),
        ];

        let result = filter_addresses(listeners.iter(), external.iter(), None);

        assert_eq!(result.len(), 1);
    }

    #[test]
    fn test_is_webrtc_address() {
        assert!(is_webrtc_address("/ip4/1.2.3.4/udp/9003/webrtc-direct/certhash/uEiD"));
        assert!(is_webrtc_address("/ip4/1.2.3.4/udp/9003/webrtc/certhash/uEiD"));
        assert!(!is_webrtc_address("/ip4/1.2.3.4/tcp/9000"));
        assert!(!is_webrtc_address("/ip4/1.2.3.4/udp/9000/quic-v1"));
    }

    #[test]
    fn test_default_protocols() {
        let protocols = default_protocols();
        assert!(protocols.contains(&"/nsn/video/1.0.0".to_string()));
        assert!(protocols.contains(&"/ipfs/id/1.0.0".to_string()));
    }
}
```

Then update `node-core/crates/p2p/src/lib.rs`:
- Add `mod discovery;` near other module declarations
- Add `pub use discovery::{default_protocols, filter_addresses, is_webrtc_address, P2pFeatures, P2pInfoData, P2pInfoError, P2pInfoErrorPayload, P2pInfoResponse};` to the public re-exports
  </action>
  <verify>
`cargo test -p nsn-p2p discovery::` runs all discovery module tests and they pass.
  </verify>
  <done>
discovery.rs module exists with P2pInfoResponse (including protocols field), filter_addresses, all tests pass, module exported from lib.rs.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add /p2p/info endpoint to HTTP server with CORS and 503 handling</name>
  <files>
    node-core/crates/p2p/src/service.rs
  </files>
  <action>
Modify the `serve_metrics` function in `node-core/crates/p2p/src/service.rs` to also handle `/p2p/info` requests with proper 503 handling when swarm is not ready.

1. First, add a new struct to share state with the HTTP handler. Add near line 85 (after SecurityState):

```rust
/// Shared state for HTTP discovery endpoint
#[derive(Clone)]
pub struct DiscoveryState {
    /// Local peer ID
    pub peer_id: PeerId,
    /// WebRTC enabled flag
    pub webrtc_enabled: bool,
    /// Node role
    pub role: String,
    /// External address override
    pub external_address: Option<String>,
    /// Channel to query swarm for current addresses
    pub addr_tx: tokio::sync::watch::Sender<(Vec<Multiaddr>, Vec<Multiaddr>)>,
    pub addr_rx: tokio::sync::watch::Receiver<(Vec<Multiaddr>, Vec<Multiaddr>)>,
}
```

2. Modify P2pService::new() to create the discovery state. After creating the swarm and before returning, add:

```rust
// Create discovery state for HTTP endpoint
let (addr_tx, addr_rx) = tokio::sync::watch::channel((Vec::new(), Vec::new()));
```

Store in P2pService struct (add field: `discovery_state: Option<DiscoveryState>`) and initialize:

```rust
let discovery_state = DiscoveryState {
    peer_id: local_peer_id,
    webrtc_enabled: config.enable_webrtc,
    role: node_mode_to_role(&cli_mode), // Will need to be passed in or defaulted
    external_address: config.external_address.clone(),
    addr_tx: addr_tx.clone(),
    addr_rx,
};
```

Actually, simpler approach: The discovery endpoint needs swarm state. Instead of complex state sharing, update the serve_metrics function signature and logic.

**SIMPLIFIED APPROACH:**

Replace the `serve_metrics` function with a more comprehensive HTTP server that handles both metrics and discovery. The key changes:

1. Add imports at top of service.rs:
```rust
use super::discovery::{default_protocols, filter_addresses, P2pFeatures, P2pInfoData, P2pInfoResponse};
use std::sync::atomic::{AtomicBool, Ordering};
```

2. Create a new shared state struct for the HTTP server (add after ServiceError):
```rust
/// Shared state for HTTP endpoints
struct HttpState {
    registry: prometheus::Registry,
    peer_id: PeerId,
    webrtc_enabled: bool,
    role: String,
    external_address: Option<String>,
    /// Current listening addresses (updated by swarm event loop)
    listeners: Arc<tokio::sync::RwLock<Vec<Multiaddr>>>,
    /// Current external addresses (updated by swarm event loop)
    external_addrs: Arc<tokio::sync::RwLock<Vec<Multiaddr>>>,
    /// Flag indicating swarm is ready (has at least one listener)
    swarm_ready: Arc<AtomicBool>,
    /// Supported protocols (static list for now)
    protocols: Vec<String>,
}
```

3. Replace the `serve_metrics` function with:
```rust
async fn serve_http(
    state: Arc<HttpState>,
    addr: SocketAddr,
) -> Result<(), hyper::Error> {
    let make_svc = make_service_fn(move |_| {
        let state = state.clone();
        async move {
            Ok::<_, Infallible>(service_fn(move |req: Request<Body>| {
                let state = state.clone();
                async move {
                    // CORS headers for all responses
                    let cors_headers = [
                        (hyper::header::ACCESS_CONTROL_ALLOW_ORIGIN, "*"),
                        (hyper::header::ACCESS_CONTROL_ALLOW_METHODS, "GET, OPTIONS"),
                        (hyper::header::ACCESS_CONTROL_ALLOW_HEADERS, "Content-Type"),
                        (hyper::header::CACHE_CONTROL, "no-store, max-age=0"),
                    ];

                    // Handle CORS preflight
                    if req.method() == hyper::Method::OPTIONS {
                        let mut response = Response::new(Body::empty());
                        for (key, value) in &cors_headers {
                            response.headers_mut().insert(*key, value.parse().unwrap());
                        }
                        return Ok::<_, Infallible>(response);
                    }

                    let path = req.uri().path();

                    let (status, content_type, body, extra_headers) = match path {
                        "/p2p/info" => {
                            // Check if swarm is ready (has listeners)
                            if !state.swarm_ready.load(Ordering::SeqCst) {
                                let response = P2pInfoResponse::error(
                                    "NODE_INITIALIZING",
                                    "Swarm not ready, please retry"
                                );
                                let json = serde_json::to_string(&response)
                                    .unwrap_or_else(|_| r#"{"success":false,"error":{"code":"SERIALIZATION_ERROR","message":"Failed to serialize response"}}"#.to_string());
                                // Return 503 with Retry-After: 5 header
                                (503, "application/json", json, Some(("Retry-After", "5")))
                            } else {
                                // Get current addresses
                                let listeners = state.listeners.read().await;
                                let external_addrs = state.external_addrs.read().await;

                                let multiaddrs = filter_addresses(
                                    listeners.iter(),
                                    external_addrs.iter(),
                                    state.external_address.as_deref(),
                                );

                                let data = P2pInfoData {
                                    peer_id: state.peer_id.to_string(),
                                    multiaddrs,
                                    protocols: state.protocols.clone(),
                                    features: P2pFeatures {
                                        webrtc_enabled: state.webrtc_enabled,
                                        role: state.role.clone(),
                                    },
                                };

                                let response = P2pInfoResponse::success(data);
                                let json = serde_json::to_string(&response)
                                    .unwrap_or_else(|_| r#"{"success":false,"error":{"code":"SERIALIZATION_ERROR","message":"Failed to serialize response"}}"#.to_string());

                                (200, "application/json", json, None)
                            }
                        }
                        "/metrics" | "/" => {
                            // Prometheus metrics
                            let metric_families = state.registry.gather();
                            let encoder = TextEncoder::new();
                            let mut buffer = Vec::new();
                            encoder.encode(&metric_families, &mut buffer).unwrap_or_default();

                            (200, encoder.format_type(), String::from_utf8(buffer).unwrap_or_default(), None)
                        }
                        _ => {
                            (404, "text/plain", "Not Found".to_string(), None)
                        }
                    };

                    let mut response = Response::builder()
                        .status(status)
                        .header(hyper::header::CONTENT_TYPE, content_type)
                        .body(Body::from(body))
                        .unwrap_or_else(|_| Response::new(Body::from("Internal error")));

                    // Add CORS headers
                    for (key, value) in &cors_headers {
                        response.headers_mut().insert(*key, value.parse().unwrap());
                    }

                    // Add extra headers (like Retry-After for 503)
                    if let Some((key, value)) = extra_headers {
                        response.headers_mut().insert(
                            hyper::header::HeaderName::from_static(key.to_lowercase().leak()),
                            value.parse().unwrap()
                        );
                    }

                    Ok::<_, Infallible>(response)
                }
            }))
        }
    });

    info!("HTTP server listening on http://{} (metrics: /metrics, discovery: /p2p/info)", addr);
    Server::bind(&addr).serve(make_svc).await
}
```

4. In P2pService struct, add fields:
```rust
/// Shared listeners for HTTP discovery endpoint
http_listeners: Arc<tokio::sync::RwLock<Vec<Multiaddr>>>,
/// Shared external addresses for HTTP discovery endpoint
http_external_addrs: Arc<tokio::sync::RwLock<Vec<Multiaddr>>>,
/// Flag indicating swarm is ready
swarm_ready: Arc<AtomicBool>,
```

5. In P2pService::new(), create these:
```rust
let http_listeners = Arc::new(tokio::sync::RwLock::new(Vec::new()));
let http_external_addrs = Arc::new(tokio::sync::RwLock::new(Vec::new()));
let swarm_ready = Arc::new(AtomicBool::new(false));
```

6. Update the metrics server spawn to use new function:
```rust
if config.metrics_port != 0 {
    let http_state = Arc::new(HttpState {
        registry: metrics.registry.clone(),
        peer_id: local_peer_id,
        webrtc_enabled: config.enable_webrtc,
        role: "node".to_string(), // Default role, can be parameterized later
        external_address: config.external_address.clone(),
        listeners: http_listeners.clone(),
        external_addrs: http_external_addrs.clone(),
        swarm_ready: swarm_ready.clone(),
        protocols: default_protocols(),
    });
    let metrics_addr: SocketAddr = ([0, 0, 0, 0], config.metrics_port).into();
    tokio::spawn(async move {
        if let Err(err) = serve_http(http_state, metrics_addr).await {
            error!("HTTP server failed: {}", err);
        }
    });
}
```

7. In the event loop, when NewListenAddr is received, update the shared state AND set swarm_ready:
```rust
SwarmEvent::NewListenAddr { address, .. } => {
    // Update shared state for HTTP discovery
    {
        let mut listeners = self.http_listeners.write().await;
        if !listeners.contains(&address) {
            listeners.push(address.clone());
        }
    }
    // Mark swarm as ready once we have at least one listener
    self.swarm_ready.store(true, Ordering::SeqCst);
    // ... existing handling
}
```

8. Similarly, when external addresses are added (in configure_nat), update:
```rust
// After swarm.add_external_address:
{
    let mut ext = self.http_external_addrs.write().await;
    if !ext.contains(&multiaddr) {
        ext.push(multiaddr.clone());
    }
}
```

**CRITICAL: 503 Response Requirements (CONTEXT.md Decision 2):**
- When `swarm_ready` is false (no listeners yet), return HTTP 503
- Response body: `{"success":false,"error":{"code":"NODE_INITIALIZING","message":"Swarm not ready, please retry"}}`
- Include `Retry-After: 5` header to tell client to retry in 5 seconds
  </action>
  <verify>
1. `cargo check -p nsn-p2p` compiles without errors
2. Start a test node and verify:
   - `curl http://127.0.0.1:9100/p2p/info` returns valid JSON with `protocols` field
   - Response has `success: true`
   - Response has `peer_id`, `multiaddrs`, `protocols`, `features`
   - `curl -I http://127.0.0.1:9100/p2p/info` shows `Access-Control-Allow-Origin: *` header
3. Verify 503 handling:
   - During startup (before first listener), endpoint returns 503
   - Response includes `Retry-After: 5` header
   - Response body has `code: "NODE_INITIALIZING"`
  </verify>
  <done>
HTTP server handles both /metrics and /p2p/info endpoints. CORS headers present. 503 returned with Retry-After:5 header when swarm not ready. Protocols field included in response. Listeners shared via RwLock.
  </done>
</task>

<task type="auto">
  <name>Task 3: Add integration test for discovery endpoint including 503 handling</name>
  <files>
    node-core/crates/p2p/src/service.rs
  </files>
  <action>
Add integration tests to the existing tests module in service.rs. Add after the existing tests:

```rust
#[tokio::test]
async fn test_discovery_endpoint_returns_valid_json() {
    use tempfile::TempDir;

    // Skip if network not allowed
    if !network_allowed() {
        return;
    }

    let temp_dir = TempDir::new().expect("Failed to create temp dir");

    let mut config = P2pConfig {
        metrics_port: 19200, // Use unique port for test
        enable_webrtc: true,
        webrtc_port: 19203,
        data_dir: Some(temp_dir.path().to_path_buf()),
        ..Default::default()
    };
    config.bootstrap.require_signed_manifests = false;
    config.bootstrap.signer_config.source = crate::SignerSource::Static;

    let (service, cmd_tx) = create_test_service_with_config(config.clone()).await;
    let handle = spawn_service(service);
    wait_for_startup().await;

    // Wait a bit more for HTTP server to start
    tokio::time::sleep(std::time::Duration::from_millis(500)).await;

    // Fetch discovery endpoint
    let client = reqwest::Client::new();
    let response = client
        .get("http://127.0.0.1:19200/p2p/info")
        .send()
        .await
        .expect("Failed to fetch /p2p/info");

    assert_eq!(response.status(), 200);

    // Check CORS header
    let cors = response.headers().get("access-control-allow-origin");
    assert!(cors.is_some(), "Should have CORS header");
    assert_eq!(cors.unwrap(), "*");

    // Check Cache-Control header
    let cache = response.headers().get("cache-control");
    assert!(cache.is_some(), "Should have Cache-Control header");
    assert!(cache.unwrap().to_str().unwrap().contains("no-store"));

    // Parse JSON
    let json: serde_json::Value = response.json().await.expect("Failed to parse JSON");

    assert_eq!(json["success"], true);
    assert!(json["data"]["peer_id"].is_string());
    assert!(json["data"]["multiaddrs"].is_array());
    assert!(json["data"]["protocols"].is_array(), "Should have protocols field");
    assert!(json["data"]["protocols"].as_array().unwrap().len() > 0, "Protocols should not be empty");
    assert_eq!(json["data"]["features"]["webrtc_enabled"], true);

    shutdown_service(cmd_tx, handle).await;
}

#[tokio::test]
async fn test_discovery_endpoint_cors_preflight() {
    if !network_allowed() {
        return;
    }

    let temp_dir = tempfile::TempDir::new().expect("Failed to create temp dir");

    let mut config = P2pConfig {
        metrics_port: 19201,
        data_dir: Some(temp_dir.path().to_path_buf()),
        ..Default::default()
    };
    config.bootstrap.require_signed_manifests = false;
    config.bootstrap.signer_config.source = crate::SignerSource::Static;

    let (service, cmd_tx) = create_test_service_with_config(config.clone()).await;
    let handle = spawn_service(service);
    wait_for_startup().await;
    tokio::time::sleep(std::time::Duration::from_millis(500)).await;

    // Send OPTIONS preflight request
    let client = reqwest::Client::new();
    let response = client
        .request(reqwest::Method::OPTIONS, "http://127.0.0.1:19201/p2p/info")
        .send()
        .await
        .expect("Failed OPTIONS request");

    assert_eq!(response.status(), 200);

    let allow_methods = response.headers().get("access-control-allow-methods");
    assert!(allow_methods.is_some());
    assert!(allow_methods.unwrap().to_str().unwrap().contains("GET"));

    shutdown_service(cmd_tx, handle).await;
}

#[tokio::test]
async fn test_discovery_endpoint_503_before_ready() {
    if !network_allowed() {
        return;
    }

    // This test verifies the 503 response logic exists in the code.
    // Testing the actual race condition (hitting endpoint before swarm is ready)
    // is tricky in integration tests. Instead, we verify:
    // 1. The endpoint eventually returns 200 (proving it becomes ready)
    // 2. The 503 error response structure is correct via unit tests

    let temp_dir = tempfile::TempDir::new().expect("Failed to create temp dir");

    let mut config = P2pConfig {
        metrics_port: 19202,
        data_dir: Some(temp_dir.path().to_path_buf()),
        ..Default::default()
    };
    config.bootstrap.require_signed_manifests = false;
    config.bootstrap.signer_config.source = crate::SignerSource::Static;

    let (service, cmd_tx) = create_test_service_with_config(config.clone()).await;
    let handle = spawn_service(service);

    // Try to hit endpoint immediately (might get 503 or connection refused)
    let client = reqwest::Client::builder()
        .timeout(std::time::Duration::from_millis(100))
        .build()
        .unwrap();

    // Wait for service to be fully ready
    wait_for_startup().await;
    tokio::time::sleep(std::time::Duration::from_millis(500)).await;

    // Now should get 200
    let response = client
        .get("http://127.0.0.1:19202/p2p/info")
        .timeout(std::time::Duration::from_secs(2))
        .send()
        .await
        .expect("Failed to fetch /p2p/info after startup");

    assert_eq!(response.status(), 200, "Should be ready after startup");

    shutdown_service(cmd_tx, handle).await;
}
```

Add reqwest to p2p crate dev-dependencies in Cargo.toml if not already present:
```toml
[dev-dependencies]
reqwest = { version = "0.11", features = ["json"] }
```

Also add a unit test in discovery.rs for the 503 error response format:

```rust
#[test]
fn test_node_initializing_error_format() {
    // This tests the error response format for 503 NODE_INITIALIZING
    let response = P2pInfoResponse::error("NODE_INITIALIZING", "Swarm not ready, please retry");
    let json = serde_json::to_string(&response).expect("serialize");

    assert!(json.contains("\"success\":false"));
    assert!(json.contains("\"code\":\"NODE_INITIALIZING\""));
    assert!(json.contains("\"message\":\"Swarm not ready, please retry\""));
    assert!(!json.contains("\"data\""));
}
```
  </action>
  <verify>
`cargo test -p nsn-p2p test_discovery_endpoint` runs all integration tests and they pass.
`cargo test -p nsn-p2p test_node_initializing` verifies 503 error format.
  </verify>
  <done>
Integration tests verify /p2p/info returns valid JSON with CORS headers, protocols field, and OPTIONS preflight works. Unit test verifies NODE_INITIALIZING 503 response format.
  </done>
</task>

</tasks>

<verification>
Run the following to verify all plan objectives are met:

```bash
# 1. Verify compilation
cargo check -p nsn-p2p

# 2. Run all p2p crate tests
cargo test -p nsn-p2p

# 3. Run discovery-specific tests
cargo test -p nsn-p2p discovery::
cargo test -p nsn-p2p test_discovery_endpoint
cargo test -p nsn-p2p test_node_initializing

# 4. Verify discovery module is exported
grep -n "pub mod discovery" node-core/crates/p2p/src/lib.rs
grep -n "P2pInfoResponse" node-core/crates/p2p/src/lib.rs

# 5. Manual endpoint test (requires running node)
# Start node: cargo run -p nsn-node -- super-node --p2p-metrics-port 9615 --p2p-enable-webrtc
# curl http://127.0.0.1:9615/p2p/info | jq
# Verify protocols field in response
```
</verification>

<success_criteria>
1. `cargo check -p nsn-p2p` succeeds with no errors
2. `cargo test -p nsn-p2p` passes all tests including new discovery:: tests
3. `/p2p/info` endpoint returns JSON with `success`, `data.peer_id`, `data.multiaddrs`, `data.protocols`, `data.features`
4. Response includes CORS headers (`Access-Control-Allow-Origin: *`)
5. Response includes `Cache-Control: no-store, max-age=0`
6. Response includes `protocols` array with at least `/nsn/video/1.0.0`
7. 503 status with `Retry-After: 5` header returned when swarm not initialized
8. 503 response body contains `code: "NODE_INITIALIZING"` and `message: "Swarm not ready, please retry"`
9. WebRTC multiaddr appears in response when WebRTC is enabled
10. Address filtering works (external_address override replaces internal addresses)
</success_criteria>

<output>
After completion, create `.planning/phases/02-discovery-bridge/02-01-SUMMARY.md`
</output>
